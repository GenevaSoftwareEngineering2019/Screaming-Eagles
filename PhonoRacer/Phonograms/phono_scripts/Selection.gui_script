function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("#", "hide_Selection")
	self.active = false
	pickedPhonoSound = ""
	pickedPhonoValue = ""
	IsActive = self.active
	iPlayerScore = 0
	-- probably redundant but needed for working
	bIsCorrectGlobal1 = false
	bIsCorrectGlobal2 = false
	Session = {}
end

function on_message(self, message_id, message, sender)
	if self.active == true then
		msg.post(".", "acquire_input_focus")
	end
	if message_id == hash("show_Selection") then
		msg.post("#", "enable")
		self.active = true
		msg.post(".", "acquire_input_focus")

		--lua tables begin at 1, not 0
		-- set int1 random to 1 - n/2,
		-- set int2 random to n/2+1 - total
		-- total is the number of values to select from, beginning at 1
		-- randomseed needs to be called twice for two different numbers
		total = 70
		total2 = total - 1
		n1 = total2 / 2
		n2 = n1 + 1
		math.randomseed(os.time() * 123456)
		ind1 = math.random(1, total)
		math.randomseed(os.clock() * 420)
		--ind2 = math.random(n2, total)
		ind2 = math.random(1, total)	
		-- feed ind1 and ind2 to either collection factory or phontab table, or print to text
		local Phono1 = gui.get_node("text1")
		local Phono2 = gui.get_node("text2")
		phonograms = {"a", "ai", "ar", "au", "aw", "ay", "b", "c", "ch", "ci", "ck", "d", "dge", "e", "ea", "ear", "ed", "ee", "ei", "eigh", "er", "eu", "ew", "ey", "f", "g", "gn", "h", "i", "ie", "igh", "ir", "j", "k", "kn", "l", "m", "n", "ng", "o", "oa", "oe", "oi", "oo", "or", "ou", "ough", "ow", "oy", "p", "ph", "qu", "r", "s", "sh", "si", "t", "tch", "th", "ti", "u", "ui", "ur", "v", "w", "wh", "wor", "wr", "x", "y", "z" }
		gui.set_text(Phono1, phonograms[ind1])
		pickedPhono1 = "Selection#" .. ind1
		gui.set_text(Phono2, phonograms[ind2])
		pickedPhono2 = "Selection#" .. ind2
		table.insert(Session, phonograms[ind1])
		table.insert(Session, phonograms[ind2])
	
	elseif message_id == hash("hide_Selection") then
		msg.post("#", "disable")
		self.active = false
	end

--decides which one is coorect
--generates random boolean
-- bIsCorrect1 is for left phonogram, 2 for right, both transferred to global variant
	math.randomseed(os.time() * 10)
	rand = math.random(100)
	if rand < 50 then
		bIsCorrect1 = true
		bIsCorrect2 = false
		pickedPhonoSound = "Selection#" .. ind1
		pickedPhonoValue = ind1
		if self.active == true then
			msg.post(pickedPhono1, "play_sound", {delay = 0, gain = 0.5})
		end
	else
		bIscorrect1 = false
		bIsCorrect2 = true
		local using2 = ind2
		pickedPhonoSound = "Selection#" .. ind2
		pickedPhonoValue = ind2
		if self.active == true then
			msg.post(pickedPhono2, "play_sound", {delay = 0, gain = 0.5})
		end
	end
end
-- setting the redundant global correct variables
bIsCorrectGlobal1 = bIsCorrect1
bIsCorrectGlobal2 = bIsCorrect2


--This depreciated method is something I am working on long term as a solution
--to the retrieving results issue. 
--[[	if action_id == hash("click") and action.pressed and self.active then
local Phono1 = gui.get_node("Phono1")
local Phono2 = gui.get_node("Phono2")
if gui.pick_node(Phono1, action.x, action.y) then
--			if Phono1.Text = pickedSound then
--then
msg.post("Selection#Congratulations", "play_sound", {delay = 0, gain = 0.5})
msg.post("#", "hide_Selection")
--elseif 
--msg.post("Selection#Bettter luck next time", "play_sound", {delay = 0, gain = 0.5})
--	msg.post("#", "hide_Selection")
--end
elseif gui.pick_node(Phono2, action.x, action.y) then
--if Phono2.Text = pickedSound
--			-then
msg.post("Selection#Congratulations", "play_sound", {delay = 0, gain = 0.5})
msg.post("#", "hide_Selection")
--elseif 
--msg.post("Selection#Bettter luck next time", "play_sound", {delay = 0, gain = 0.5})
--msg.post("#", "hide_Selection")
--end
end ]]--

function on_input(self, action_id, action)
if action_id == hash("click") and action.pressed and self.active then
	local Phono1 = gui.get_node("Phono1")
	local Phono2 = gui.get_node("Phono2")
	local SoundButton = gui.get_node("SoundButton")
	if gui.pick_node(SoundButton, action.x, action.y) then
		msg.post(pickedPhonoSound, "play_sound", {delay = 0, gain = 0.5})	
	end
	
	-- if left node selected
	if gui.pick_node(Phono1, action.x, action.y) then
		-- check if correct answer
		if bIsCorrect1 == true then
			iPlayerScore = iPlayerScore + 1
			print(iPlayerScore)
			-- play correct sound
		elseif bIsCorrect1 == false then
			print(iPlayerScore)
			-- play incorrect sound
		end 
		msg.post("#", "hide_Selection")
		msg.post("default:/GamescreenProxy#GamescreenLoader", "Resume")
	-- if right node selecte
	elseif gui.pick_node(Phono2, action.x, action.y) then
		if bIsCorrect2 == true then
			iPlayerScore = iPlayerScore + 1
			print(iPlayerScore)
			-- play correct sound
			--msg.post(play_sound, )
		elseif bIsCorrect2 == false then
			-- play incorrect sound
			print(iPlayerScore)
		end
		msg.post("#", "hide_Selection")
		msg.post("default:/GamescreenProxy#GamescreenLoader", "Resume")
		end
	end
end